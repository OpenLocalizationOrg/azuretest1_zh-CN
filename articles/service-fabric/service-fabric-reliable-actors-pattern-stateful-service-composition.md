---
ms.openlocfilehash: 2ebe6ed846425e43de72b4abd82d3892017c4021
ms.sourcegitcommit: bab1265d669c3e6871daa7cb8a5640a47104947a
translationtype: MT
---

<properties
   pageTitle="可靠的演员有状态的服务组合设计模式"
   description="使用有状态的参与者来缓存以前的服务结果以及服务调用之间维护状态的服务结构可靠者设计模式。 状态可以是永久性或暂时性。"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="claudioc"/>

# 可靠的操作者设计模式︰ 有状态的服务组合
开发人员花了过去十年半生成 N 层在企业中的无状态服务。 它们建立在数据库的服务，它们建立在其他服务中，高位服务他们构建的业务流程引擎和面向消息中间件来协调这些服务。 随着用户工作负载的变化，是否要求更多的交互性或比例，无状态的面向服务的体系结构开始显示其弱点。

## 老方法︰ SOA 服务
而 SOA 服务水平无缝地由于其无国界，它们在存储层中创建一个瓶颈 — — 并发性和吞吐量。 访问存储变得越来越昂贵。 大多数开发人员引入缓存解决方案以减少存储的需求，但解决方案不是不存在缺陷的情况下作为一种常见的做法 — — 另一层管理，并发访问缓存时，语义限制更改，并最终一致性。 前面详细介绍的智能高速缓存模式，虚拟使用者模型为此提供完美的解决方案。

有些开发人员试图通过复制他们的存储层来解决问题。 但是，这种方法不能很好地扩展，快速达到帽边界。
第二个挑战发展周围不断变化的需求;最终用户和公司要求交互式服务 — — 对在毫秒，而不是将秒显示为标准的请求的响应。 若要响应，开发人员开始生成表面上在某些情况下 10s 的服务来创建以用户为中心的服务的其他服务的服务。 但是撰写多个下游服务快速显示延迟问题。

再一次开发人员转向了缓存和内存中对象的存储区，在某些情况下不同的实现，以满足性能要求。 他们开始构建后端工作进程，以建立定期地减少昂贵的点播缓存填充缓存。 最后，他们开始解构它们的工作负载隔离异步操作的同步，以获得更多空间的交互操作的状态，就特别难在 SOA 中的更改做出反应。

他们进一步引入层如队列和工作人员他们的解决方案添加更多的复杂性。
实质上，换句话说，开始寻找解决方案的开发人员可以构建"服务状态"布置的"状态"和"服务行为"为通讯中心和交互式的用户体验。 而这正是在 Azure 服务结构与服务组合层的演员来访，不能作为这些服务的替代。

下图说明了一点︰

![][1]

## 使用者有更好的解决方案
对于撰写服务，参与者可以是无状态或有状态。

* 无状态的参与者可以用作基础服务的代理。 这些演员在 Azure 服务结构群集可以动态扩展，可以缓存与服务，如一旦发现其终结点相关的特定信息。
* 有状态的参与者可以维护间服务调用以及缓存以前的服务结果的状态。 状态可以是永久性或暂时性。

这种模式也是适用在各种方案;在大多数情况下，参与者需要外部调用来调用特定的服务上的操作。
让我们来说明使用现代的电子商务应用程序的示例了。 这些应用程序基于提供各种功能，如用户配置文件管理、 建议、 篮管理、 愿望列表管理、 采购和许多更多的服务。

大多数开发人员希望采取一种以用户为中心的方法对其体系结构，非常类似于那些因为电子商务体验主要都围绕用户和产品开发的社会经验。 这通常被通过传送外观很可能是为了提高性能的缓存所支持的服务。

现在让我们谈谈一种基于操作者的方法。 用户操作者可以表示两个用户 （浏览目录、 喜好的产品，将项目添加到购物篮，向朋友推荐产品） 的行为以及其构成的状态 — — 他们的配置文件，在篮子里，推荐他们的朋友、 购买历史记录当前的地理位置，依次类推的项的列表项。

## 使用有状态的参与者
第一个让我们看一个示例用户参与者需要填充它从多个服务的状态。 我们不打算提供一个代码示例为这一个因为一切我们所讨论的智能高速缓存模式中也是适用在此处。
我们可以激活用户使用者在登录时，用从后端服务的足够数据填充它。 当然，如我们所看到的在许多情况下，早在本白皮书中，可以预填充即需即装上计时器，或者两位整数和部分状态并将其缓存在主角。
例如，配置文件和期望列表如下所示︰

![][2]

例如我们可以预设频繁用户的状态，并使其可在登录，或在每月访问该服务的用户的登录时对其进行填充时。 我们已经看到了这些模式的智能高速缓存中。

当用户 23 记录在中，如果不是已经激活，用户参与者 (23) 被激活并从后端服务中获取相关的用户配置文件信息和愿望。 可能的用户操作者将缓存的后续调用的信息。 然后，如果，例如，我们需要向我们可以写隐藏还是写过前面所述的期望列表中添加项。
其次，让我们看一个示例在用户单击"like"按钮上，喜欢一种产品。 此操作可能需要多个服务的多个调用，如下所示︰"像"发送到目录服务、 触发下一套建议，和可能是发布到社交网络更新。

下面对此进行了说明︰

![][3]

## 如何帮助演员组合和异步通信
事实上，当我们想要撰写以及异步操作的请求/响应样式操作非常出色 Azure 服务结构演员。 例如，尽管"类似产品"立即到用户的期望列表将喜欢的项目，发布到社交网络以及触发下一套建议可以使用缓冲区和计时器的异步操作。

使用服务的用户参与者的一个其他关键的好处是演员提供缓存状态的自然场所和最重要的是异步响应更改其状态。 这是与无状态服务尤其具有挑战性的情形。
例如，用户将执行一系列操作，可能是属于"用户旅程"。 可以在参与者实时捕获这些事件，我们可以组建一个流，我们可以查询异步事件时或一个计时器，以更改使用者的行为。

此时 SOA 纯粹主义者将肯定已经注意到这些不是在这个意义上的使用者服务作为公开通过语言独立于协议的终结点。 Azure 服务结构演员是不互操作的组件或服务进行互操作的平台。 不过，真的没有什么妨碍我们我们模型我们演员时或在建模方式相同的关注点分离的 SOA 风格服务粒度方面考虑。 此类服务被称为"microservices"。
同样，没有绝对阻止我们为 Azure 服务结构演员互操作层中放置 REST 端点或 SOAP 端点。

有状态的服务组合还将工作流和只是事务处理的方案，如电子商务应用。 因此可用于建模工作流涉及服务之间的交互并维护这些交互的状态，azure 服务结构被设计为工作流/业务流程引擎。

构建可扩展的服务，以提供动态的经验，我们可以看到"无状态服务"的缺点。 Azure 服务结构参与者，实质上是通过汇集状态和行为，可帮助开发人员构建可伸缩的和交互式的体验，在他们现有的投资。


## 下一步行动
[图案︰ 智能高速缓存](service-fabric-reliable-actors-pattern-smart-cache.md)

[图案︰ 分布式的网络和关系图](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[图案︰ 资源管理](service-fabric-reliable-actors-pattern-resource-governance.md)

[图案︰ 物联网](service-fabric-reliable-actors-pattern-internet-of-things.md)

[图案︰ 分布式的计算](service-fabric-reliable-actors-pattern-distributed-computation.md)

[一些反模式](service-fabric-reliable-actors-anti-patterns.md)

[服务结构演员简介](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png
