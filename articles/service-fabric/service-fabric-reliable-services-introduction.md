---
ms.openlocfilehash: 1e3f41df082b04c7fa82bb8f18d44851b41a7c74
ms.sourcegitcommit: bab1265d669c3e6871daa7cb8a5640a47104947a
translationtype: MT
---
<properties
   pageTitle="服务结构可靠服务编程模型概述"
   description="了解服务结构可靠服务的编程模型，并开始编写您自己的服务。"
   services="Service-Fabric"
   documentationCenter=".net"
   authors="masnider"
   manager="timlt"
   editor="jessebenson; mani-ramaswamy"/>

<tags
   ms.service="Service-Fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/26/2015"
   ms.author="masnider;jesseb"/>

# 可靠的服务概述
编写和管理可靠的无状态和有状态服务，简化了服务结构。 本文档将讨论︰

1. 无状态和有状态服务可靠服务编程模型。
2. 不同的选择，则必须进行时编写可靠的服务。
3. 一些不同的方案和何时使用可靠的服务和编写方式的示例。

可靠的服务是在服务结构上可用的编程模型之一。 可靠的参与者的编程模型的详细信息，敬请[简介](service-fabric-reliable-actors-introduction.md)。

在服务结构中，服务组成的配置，应用程序代码，以及 （可选） 状态。

服务结构从资源调配和通过升级和删除[应用程序管理服务结构](service-fabric-deploy-remove-applications.md)通过部署管理服务的生命周期。

## 可靠的服务有哪些？
可靠的服务为您提供了简单、 功能强大、 顶级的编程模型，可帮助您快速什么是对您的应用程序很重要。 您收到与可靠的服务编程模型︰

1. 有状态服务，可靠的服务编程模型允许您以一致而可靠地存储您在您的服务使用可靠的集合内的状态︰ 一组简单的来说应该很熟悉的人已使用 C# 集合的高度可用的集合类。 传统上，服务需要外部系统可靠状态管理。 对于可靠的集合，可以将您的状态，计算机具有相同的高可用性和可靠性是冲从高度可用的外部存储着与共存的计算和状态提供的额外延迟改进旁边。

2. 是用来运行您自己的代码看起来像编程建模您的简单模型︰ 您的代码具有良好定义的入口点和易于管理的生命周期。

3. 可插拔的通信模型-使用您的选择，例如 HTTP [Web API](service-fabric-reliable-services-communication-webapi.md)，Websocket、 自定义 TCP 协议等的传输。可靠的服务提供了从该选项可以使用，或使您可以提供您自己一些极好。

## 什么使可靠的服务不同？
可靠的服务，在服务结构是不同于您可能编写之前的服务。 可靠性、 可用性、 一致性和可扩展性，提供了服务结构。  

+ <u>可靠性</u>-您的服务将能保持正常甚至在不可靠的环境，计算机可能失败或点击网络问题。

+ <u>可用性</u>-您的服务将是可到达的且响应 (这并不意味着不能有服务无法找到或从到达之外)。

+ <u>可伸缩性</u>– 服务从特定硬件分离，可以扩大或缩小必要时通过添加或移除硬件或虚拟资源。 服务很容易地划分 （特别是在有状态的情况下） 以确保服务的独立部分可以扩展并独立地响应出现的故障。 最后，服务结构鼓励通过允许成千上万的服务，以提供在单个进程中，而不是要求或使整个 OS 实例专用于特定工作负载的一个实例是轻量的服务。

+ <u>一致性</u>-这意味着，可以保证该服务中存储的任何信息一致 （这仅适用于有状态服务-更对此以后）

## 服务生命周期
无论您的服务是有状态或无状态，可靠的服务提供了简单的生命周期，可以快速插入代码并着手实施。  没有需要为了启动并运行您的服务实现的其实只是一个或两个方法。

+ CreateCommunicationListener-这是该服务定义了它想要使用的通信栈。 通讯堆栈，如[Web API](service-fabric-reliable-services-communication-webapi.md)，是定义侦听终结点 （如何客户将到达该） 服务，也会显示这些消息得到与服务代码的其余部分交互的方式。

+ RunAsync-这是您的服务运行其业务逻辑的位置。 提供的取消标记是一个信号，对于何时应停止工作。 例如，如果您有需要不断拉 ReliableQueue 中的邮件并处理它们的服务，这是该工作会。

可靠的服务的生命周期中的主要事件如下︰

1. 构建服务对象 （从 StatelessService 或 StatefulService 的事）。

2. 调用 CreateCommunicationListener 方法，使该服务返回一个通信侦听器，其选择的有机会。
  + 请注意这是可选的但大多数服务将直接暴露某些终结点。

3. 打开通信侦听器创建后
  + 通信侦听器具有调用 open （），这种行为称为此时和它返回服务侦听地址的方法。 如果您可靠服务使用一个内置的 ICommunicationListeners，然后它处理为您。

4. 一旦通信侦听器 open （），被称为 RunAsync() 调用主服务上。
  + 注意，RunAsync 是可选的即如果服务进行所有其工作直接对用户的响应调用只，则无需为其实现 RunAsync()。

当该服务正在关闭 （或者被删除或只是从一个特定的位置被移动时） 调用顺序相同，则第一个 close （） 调用通信侦听器，然后传递给 RunAsync() 的取消标记将被取消。

## 示例服务
知道此编程模型，让我们快速回顾一下两个不同的服务，若要查看这些组件结合在一起。

### 可靠的无状态服务
无状态的服务是一个实际上是无状态保留在服务中，或存在的状态完全可释放，不需要同步、 复制、 持久性或高可用性。

例如，请考虑没有内存，一个计算器，它接收所有条款和一次执行的操作。

在这种情况下，因为没有后台任务处理，执行所需的服务，服务的 RunAsync() 可以为空。 创建计算器服务时，它将返回 CommunicationListener (例如[Web API](service-fabric-reliable-services-communication-webapi.md)) 打开某些端口上侦听终结点。 此侦听终结点将挂钩到的不同方法 (ex:"添加 （n1、 n2）") 的定义计算器的公共 API。

当从客户端进行调用时，调用相应的方法时，和计算器服务提供对数据的运算并返回结果。 它不会存储任何状态。

不存储任何内部状态使计算器本示例非常简单。 但是大多数服务并不能真正无状态-而这些外部它们对某些存储 （例如，任何 web 应用程序依赖于保持后备存储或缓存中的状态不是完全无状态的会话） 的状态。

常见的示例服务结构中使用无状态的服务的方式是作为公开面向公众的 API 为 web 应用程序的前端。 有状态服务来完成用户的请求，然后讨论前端服务。 在这种情况下，客户端的调用会被定向到已知端口 80 如无状态服务正在侦听其中。 此无状态服务收到调用并确定调用是否来自受信任方，作为以及哪些服务发送给。  然后，无状态服务将转发到正确的分区的有状态的服务调用，并等待响应。 当接收到响应时，该答复回原始客户端。

### 可靠的有状态服务
有状态的服务是一种必须具有状态函数保持一致，并使该服务中存在的某些部分。 请考虑服务不断计算某个值基于接收的更新的滚动平均值。 为了做到这一点，它必须有两个当前的传入请求的过程以及当前平均需要集。 检索、 处理，并将信息存储在外部存储 （如 Azure Blob 或表存储今天） 的任何服务是有状态-只需保留其状态的外部状态存储区中。

大多数服务目前存储其状态从外部由于外部存储于该状态提供可靠性、 可用性、 可扩展性和一致性。 在服务结构中，有状态服务无需外部存储它们的状态，因为服务结构处理这些需求的服务代码和服务状态。

让我们假设我们想要编写服务采取的一系列图像，并转换所需的图像上执行所需的转换请求。  这项服务，它将返回 CommunicationListener （假设 WebAPI） 打开通讯端口，并允许通过 API 提交如下所示的`ConvertImage(Image i, IList<Conversion> conversions)`。 此 API 中服务无法获取信息并将该请求存储在 ReliableQueue 中，然后向客户端返回一些标记，以便它可以跟踪的请求 （由于请求可能需要花费一些时间）。

此服务在 RunAsync 可能是更复杂︰ 服务者必须在其 RunAsync，提取 ReliableQueue 请求、 执行转换列出，并将结果存储在 ReliableDictionary 中，以便客户端回发时他们可以获得他们转换后的图像内循环。 为了确保即使事情失败图像将不会丢失，此可靠服务将拉从队列中移除、 执行转换，并将结果存储在事务中，以便从队列并存储结果字典中完成转换后的结果只有实际移除消息。 如果事情无法正常工作 （如本例中的代码运行的计算机） 的中间，请求仍保留在队列中等待处理。

要注意与此服务有关的一点是，这听起来像正常的.NET 服务，即唯一的区别是 （ReliableQueue 和 ReliableDictionary） 的数据结构正在使用所提供的服务结构，因此进行了高可靠、 可用且一致。

## 何时使用可靠的服务的 Api
如果下列任一定义您应用程序的服务需求，则应被视为可靠的服务 Api:

- 您需要在多台设备的状态 （例如，订单和订单行项） 中提供了应用程序的行为

- 应用程序的状态可以自然地作为可靠的词典和队列建模

- 需要高可用性具有低延迟访问您的状态

- 应用程序需要跨一个或多个可靠集合控制并发或事务处理操作的粒度

- 您想要管理的通信或控制您的服务的分区方案

- 您的代码需要自由线程运行时环境

- 应用程序需要动态创建或销毁可靠的词典或在运行时的队列

- 您需要以编程方式控制服务结构提供备份和恢复功能服务的状态 *

- 应用程序需要维护的状态 * 其单位的更改历史记录

- 您想要开发，或使用第三方开发的自定义状态提供程序 *

> [AZURE.NOTE] * SDK 正式供货时可用的功能


## 下一步行动
+ [可靠的服务快速入门](service-fabric-reliable-services-quick-start.md)
+ [签出可靠的服务高级用法](service-fabric-reliable-services-advanced-usage.md)
+ [阅读的可靠参与者的编程模型](service-fabric-reliable-actors-introduction.md)
 
